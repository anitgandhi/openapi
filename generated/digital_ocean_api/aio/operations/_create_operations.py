# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.8.3, generator: @autorest/python@5.16.0)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Optional, TypeVar, Union

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._vendor import _convert_request
from ...operations._create_operations import build_alert_policy_request, build_app_request, build_cdn_endpoint_request, build_certificates_request, build_custom_image_request, build_database_cluster_request, build_deployment_request, build_domain_record_request, build_domain_request, build_droplet_request, build_firewall_request, build_floating_ip_request, build_kubernetes_cluster_request, build_load_balancer_request, build_new_tag_request, build_new_volume_request, build_project_request, build_registry_request, build_replica_request, build_ssh_key_request, build_volume_snapshot_request, build_vpc_request
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class CreateOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~digital_ocean_api.aio.DigitalOceanAPI`'s
        :attr:`create` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def ssh_key(
        self,
        body: _models.SshKey,
        **kwargs: Any
    ) -> Union[_models.Components1HarxvuResponsesKeyCreatedContentApplicationJsonSchema, _models.Error]:
        """Create a New SSH Key.

        To add a new SSH public key to your DigitalOcean account, send a POST request to
        ``/v2/account/keys``. Set the ``name`` attribute to the name you wish to use and the
        ``public_key`` attribute to the full public key you are adding.

        :param body:
        :type body: ~digital_ocean_api.models.SshKey
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components1HarxvuResponsesKeyCreatedContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components1HarxvuResponsesKeyCreatedContentApplicationJsonSchema or
         ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components1HarxvuResponsesKeyCreatedContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'SshKey')

        request = build_ssh_key_request(
            content_type=content_type,
            json=_json,
            template_url=self.ssh_key.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components1HarxvuResponsesKeyCreatedContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    ssh_key.metadata = {'url': "/v2/account/keys"}  # type: ignore


    @distributed_trace_async
    async def app(
        self,
        body: _models.AppsCreateAppRequest,
        **kwargs: Any
    ) -> Union[_models.AppResponse, _models.Error]:
        """Create a New App.

        Create a new app by submitting an app specification. For documentation on app specifications (\
        ``AppSpec`` objects), please refer to `the product documentation
        <https://www.digitalocean.com/docs/app-platform/references/app-specification-reference/>`_.

        :param body:
        :type body: ~digital_ocean_api.models.AppsCreateAppRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AppResponse or Error, or the result of cls(response)
        :rtype: ~digital_ocean_api.models.AppResponse or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.AppResponse, _models.Error]]

        _json = self._serialize.body(body, 'AppsCreateAppRequest')

        request = build_app_request(
            content_type=content_type,
            json=_json,
            template_url=self.app.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('AppResponse', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    app.metadata = {'url': "/v2/apps"}  # type: ignore


    @distributed_trace_async
    async def deployment(
        self,
        body: _models.AppsCreateDeploymentRequest,
        **kwargs: Any
    ) -> Union[_models.AppsDeploymentResponse, _models.Error]:
        """Create an App Deployment.

        Creating an app deployment will pull the latest changes from your repository and schedule a new
        deployment for your app.

        :param body:
        :type body: ~digital_ocean_api.models.AppsCreateDeploymentRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AppsDeploymentResponse or Error, or the result of cls(response)
        :rtype: ~digital_ocean_api.models.AppsDeploymentResponse or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.AppsDeploymentResponse, _models.Error]]

        _json = self._serialize.body(body, 'AppsCreateDeploymentRequest')

        request = build_deployment_request(
            app_id=self._config.app_id,
            content_type=content_type,
            json=_json,
            template_url=self.deployment.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('AppsDeploymentResponse', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 404:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    deployment.metadata = {'url': "/v2/apps/{app_id}/deployments"}  # type: ignore


    @distributed_trace_async
    async def cdn_endpoint(
        self,
        body: _models.CdnEndpoint,
        **kwargs: Any
    ) -> Union[_models.ComponentsVd6C9CResponsesExistingEndpointContentApplicationJsonSchema, _models.Error]:
        """Create a New CDN Endpoint.

        To create a new CDN endpoint, send a POST request to ``/v2/cdn/endpoints``. The
        origin attribute must be set to the fully qualified domain name (FQDN) of a
        DigitalOcean Space. Optionally, the TTL may be configured by setting the ``ttl``
        attribute.

        A custom subdomain may be configured by specifying the ``custom_domain`` and
        ``certificate_id`` attributes.

        :param body:
        :type body: ~digital_ocean_api.models.CdnEndpoint
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentsVd6C9CResponsesExistingEndpointContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.ComponentsVd6C9CResponsesExistingEndpointContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.ComponentsVd6C9CResponsesExistingEndpointContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'CdnEndpoint')

        request = build_cdn_endpoint_request(
            content_type=content_type,
            json=_json,
            template_url=self.cdn_endpoint.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('ComponentsVd6C9CResponsesExistingEndpointContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    cdn_endpoint.metadata = {'url': "/v2/cdn/endpoints"}  # type: ignore


    @distributed_trace_async
    async def certificates(
        self,
        body: Any,
        **kwargs: Any
    ) -> Union[_models.ComponentsOispf1ResponsesNewCertificateContentApplicationJsonSchema, _models.Error]:
        """Create a New Certificate.

        To upload new SSL certificate which you have previously generated, send a POST
        request to ``/v2/certificates``.

        When uploading a user-generated certificate, the ``private_key``\ ,
        ``leaf_certificate``\ , and optionally the ``certificate_chain`` attributes should
        be provided. The type must be set to ``custom``.

        When using Let's Encrypt to create a certificate, the ``dns_names`` attribute
        must be provided, and the type must be set to ``lets_encrypt``.

        :param body:
        :type body: any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentsOispf1ResponsesNewCertificateContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.ComponentsOispf1ResponsesNewCertificateContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.ComponentsOispf1ResponsesNewCertificateContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'object')

        request = build_certificates_request(
            content_type=content_type,
            json=_json,
            template_url=self.certificates.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('ComponentsOispf1ResponsesNewCertificateContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    certificates.metadata = {'url': "/v2/certificates"}  # type: ignore


    @distributed_trace_async
    async def database_cluster(
        self,
        body: _models.PathsWztbx8V2DatabasesPostRequestbodyContentApplicationJsonSchema,
        **kwargs: Any
    ) -> Union[_models.Components15CinloResponsesDatabaseClusterContentApplicationJsonSchema, _models.Error]:
        """Create a New Database Cluster.

        To create a database cluster, send a POST request to ``/v2/databases``.
        The response will be a JSON object with a key called ``database``. The value of this will be an
        object that contains the standard attributes associated with a database cluster. The initial
        value of the database cluster's ``status`` attribute will be ``creating``. When the cluster is
        ready to receive traffic, this will transition to ``online``.
        The embedded ``connection`` and ``private_connection`` objects will contain the information
        needed to access the database cluster.
        DigitalOcean managed PostgreSQL and MySQL database clusters take automated daily backups. To
        create a new database cluster based on a backup of an exising cluster, send a POST request to
        ``/v2/databases``. In addition to the standard database cluster attributes, the JSON body must
        include a key named ``backup_restore`` with the name of the original database cluster and the
        timestamp of the backup to be restored. Creating a database  from a backup is the same as
        forking a database in the control panel.
        Note: Backups are not supported for Redis clusters.

        :param body:
        :type body:
         ~digital_ocean_api.models.PathsWztbx8V2DatabasesPostRequestbodyContentApplicationJsonSchema
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components15CinloResponsesDatabaseClusterContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components15CinloResponsesDatabaseClusterContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components15CinloResponsesDatabaseClusterContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'PathsWztbx8V2DatabasesPostRequestbodyContentApplicationJsonSchema')

        request = build_database_cluster_request(
            content_type=content_type,
            json=_json,
            template_url=self.database_cluster.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components15CinloResponsesDatabaseClusterContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 404:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    database_cluster.metadata = {'url': "/v2/databases"}  # type: ignore


    @distributed_trace_async
    async def replica(
        self,
        body: Optional[_models.PathsQqxkghV2DatabasesDatabaseClusterUuidReplicasPostRequestbodyContentApplicationJsonSchema] = None,
        **kwargs: Any
    ) -> Union[_models.Components19Fq60GResponsesDatabaseReplicaContentApplicationJsonSchema, _models.Error]:
        """Create a Read-only Replica.

        To create a read-only replica for a PostgreSQL or MySQL database cluster, send a POST request
        to ``/v2/databases/$DATABASE_ID/replicas`` specifying the name it should be given, the size of
        the node to be used, and the region where it will be located.
        **Note**\ : Read-only replicas are not supported for Redis clusters.
        The response will be a JSON object with a key called ``replica``. The value of this will be an
        object that contains the standard attributes associated with a database replica. The initial
        value of the read-only replica's ``status`` attribute will be ``forking``. When the replica is
        ready to receive traffic, this will transition to ``active``.

        :param body:  Default value is None.
        :type body:
         ~digital_ocean_api.models.PathsQqxkghV2DatabasesDatabaseClusterUuidReplicasPostRequestbodyContentApplicationJsonSchema
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components19Fq60GResponsesDatabaseReplicaContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components19Fq60GResponsesDatabaseReplicaContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components19Fq60GResponsesDatabaseReplicaContentApplicationJsonSchema, _models.Error]]

        if body is not None:
            _json = self._serialize.body(body, 'PathsQqxkghV2DatabasesDatabaseClusterUuidReplicasPostRequestbodyContentApplicationJsonSchema')
        else:
            _json = None

        request = build_replica_request(
            database_cluster_uuid=self._config.database_cluster_uuid,
            content_type=content_type,
            json=_json,
            template_url=self.replica.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components19Fq60GResponsesDatabaseReplicaContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 404:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    replica.metadata = {'url': "/v2/databases/{database_cluster_uuid}/replicas"}  # type: ignore


    @distributed_trace_async
    async def domain(
        self,
        body: Optional[_models.Domain] = None,
        **kwargs: Any
    ) -> Union[_models.Components12H0Ks2ResponsesCreateDomainResponseContentApplicationJsonSchema, _models.Error]:
        """Create a New Domain.

        To create a new domain, send a POST request to ``/v2/domains``. Set the "name"
        attribute to the domain name you are adding. Optionally, you may set the
        "ip_address" attribute, and an A record will be automatically created pointing
        to the apex domain.

        :param body:  Default value is None.
        :type body: ~digital_ocean_api.models.Domain
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components12H0Ks2ResponsesCreateDomainResponseContentApplicationJsonSchema or Error,
         or the result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components12H0Ks2ResponsesCreateDomainResponseContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components12H0Ks2ResponsesCreateDomainResponseContentApplicationJsonSchema, _models.Error]]

        if body is not None:
            _json = self._serialize.body(body, 'Domain')
        else:
            _json = None

        request = build_domain_request(
            content_type=content_type,
            json=_json,
            template_url=self.domain.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components12H0Ks2ResponsesCreateDomainResponseContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    domain.metadata = {'url': "/v2/domains"}  # type: ignore


    @distributed_trace_async
    async def domain_record(
        self,
        body: Any = None,
        **kwargs: Any
    ) -> Union[_models.Components12RmuqrResponsesCreatedDomainRecordContentApplicationJsonSchema, _models.Error]:
        """Create a New Domain Record.

        To create a new record to a domain, send a POST request to
        ``/v2/domains/$DOMAIN_NAME/records``.

        The request must include all of the required fields for the domain record type
        being added.

        See the `attribute table <#tag/Domain-Records>`_ for details regarding record
        types and their respective required attributes.

        :param body:  Default value is None.
        :type body: any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components12RmuqrResponsesCreatedDomainRecordContentApplicationJsonSchema or Error, or
         the result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components12RmuqrResponsesCreatedDomainRecordContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components12RmuqrResponsesCreatedDomainRecordContentApplicationJsonSchema, _models.Error]]

        if body is not None:
            _json = self._serialize.body(body, 'object')
        else:
            _json = None

        request = build_domain_record_request(
            domain_name=self._config.domain_name,
            content_type=content_type,
            json=_json,
            template_url=self.domain_record.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components12RmuqrResponsesCreatedDomainRecordContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 404:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    domain_record.metadata = {'url': "/v2/domains/{domain_name}/records"}  # type: ignore


    @distributed_trace_async
    async def droplet(
        self,
        body: Any = None,
        **kwargs: Any
    ) -> Union[Any, _models.Error]:
        """Create a New Droplet.

        To create a new Droplet, send a POST request to ``/v2/droplets`` setting the
        required attributes.

        A Droplet will be created using the provided information. The response body
        will contain a JSON object with a key called ``droplet``. The value will be an
        object containing the standard attributes for your new Droplet. The response
        code, 202 Accepted, does not indicate the success or failure of the operation,
        just that the request has been accepted for processing. The ``actions`` returned
        as part of the response's ``links`` object can be used to check the status
        of the Droplet create event.

        Create Multiple Droplets
        ^^^^^^^^^^^^^^^^^^^^^^^^

        Creating multiple Droplets is very similar to creating a single Droplet.
        Instead of sending ``name`` as a string, send ``names`` as an array of strings. A
        Droplet will be created for each name you send using the associated
        information. Up to ten Droplets may be created this way at a time.

        Rather than returning a single Droplet, the response body will contain a JSON
        array with a key called ``droplets``. This will be set to an array of JSON
        objects, each of which will contain the standard Droplet attributes. The
        response code, 202 Accepted, does not indicate the success or failure of any
        operation, just that the request has been accepted for processing. The array
        of ``actions`` returned as part of the response's ``links`` object can be used to
        check the status of each individual Droplet create event.

        :param body:  Default value is None.
        :type body: any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: any or Error, or the result of cls(response)
        :rtype: any or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[Any, _models.Error]]

        if body is not None:
            _json = self._serialize.body(body, 'object')
        else:
            _json = None

        request = build_droplet_request(
            content_type=content_type,
            json=_json,
            template_url=self.droplet.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 202:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('object', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    droplet.metadata = {'url': "/v2/droplets"}  # type: ignore


    @distributed_trace_async
    async def firewall(
        self,
        body: Optional[_models.Paths1Cscq1HV2FirewallsPostRequestbodyContentApplicationJsonSchema] = None,
        **kwargs: Any
    ) -> Union[_models.Components1Ppd4D8ResponsesCreateFirewallResponseContentApplicationJsonSchema, _models.Error]:
        """Create a New Firewall.

        To create a new firewall, send a POST request to ``/v2/firewalls``. The request
        must contain at least one inbound or outbound access rule.

        :param body:  Default value is None.
        :type body:
         ~digital_ocean_api.models.Paths1Cscq1HV2FirewallsPostRequestbodyContentApplicationJsonSchema
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components1Ppd4D8ResponsesCreateFirewallResponseContentApplicationJsonSchema or Error,
         or the result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components1Ppd4D8ResponsesCreateFirewallResponseContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components1Ppd4D8ResponsesCreateFirewallResponseContentApplicationJsonSchema, _models.Error]]

        if body is not None:
            _json = self._serialize.body(body, 'Paths1Cscq1HV2FirewallsPostRequestbodyContentApplicationJsonSchema')
        else:
            _json = None

        request = build_firewall_request(
            content_type=content_type,
            json=_json,
            template_url=self.firewall.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 202:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components1Ppd4D8ResponsesCreateFirewallResponseContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 400:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    firewall.metadata = {'url': "/v2/firewalls"}  # type: ignore


    @distributed_trace_async
    async def floating_ip(
        self,
        body: Any,
        **kwargs: Any
    ) -> Union[_models.ComponentsFwoxchResponsesFloatingIpCreatedContentApplicationJsonSchema, _models.Error]:
        """Create a New Floating IP.

        On creation, a floating IP must be either assigned to a Droplet or reserved to a region.


        *
          To create a new floating IP assigned to a Droplet, send a POST
          request to ``/v2/floating_ips`` with the ``droplet_id`` attribute.

        *
          To create a new floating IP reserved to a region, send a POST request to
          ``/v2/floating_ips`` with the ``region`` attribute.

        **Note**\ :  In addition to the standard rate limiting, only 12 floating IPs may be created per
        60 seconds.

        :param body:
        :type body: any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentsFwoxchResponsesFloatingIpCreatedContentApplicationJsonSchema or Error, or
         the result of cls(response)
        :rtype:
         ~digital_ocean_api.models.ComponentsFwoxchResponsesFloatingIpCreatedContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.ComponentsFwoxchResponsesFloatingIpCreatedContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'object')

        request = build_floating_ip_request(
            content_type=content_type,
            json=_json,
            template_url=self.floating_ip.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 202:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('ComponentsFwoxchResponsesFloatingIpCreatedContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    floating_ip.metadata = {'url': "/v2/floating_ips"}  # type: ignore


    @distributed_trace_async
    async def custom_image(
        self,
        body: _models.ImageNewCustom,
        **kwargs: Any
    ) -> Union[_models.Components1Ef5H32ResponsesNewCustomImageContentApplicationJsonSchema, _models.Error]:
        """Create a Custom Image.

        To create a new custom image, send a POST request to /v2/images.
        The body must contain a url attribute pointing to a Linux virtual machine
        image to be imported into DigitalOcean.
        The image must be in the raw, qcow2, vhdx, vdi, or vmdk format.
        It may be compressed using gzip or bzip2 and must be smaller than 100 GB after
         being decompressed.

        :param body:
        :type body: ~digital_ocean_api.models.ImageNewCustom
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components1Ef5H32ResponsesNewCustomImageContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components1Ef5H32ResponsesNewCustomImageContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components1Ef5H32ResponsesNewCustomImageContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'ImageNewCustom')

        request = build_custom_image_request(
            content_type=content_type,
            json=_json,
            template_url=self.custom_image.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 202:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components1Ef5H32ResponsesNewCustomImageContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    custom_image.metadata = {'url': "/v2/images"}  # type: ignore


    @distributed_trace_async
    async def kubernetes_cluster(
        self,
        body: _models.Cluster,
        **kwargs: Any
    ) -> Union[_models.ComponentsTzd5NlResponsesClusterCreateContentApplicationJsonSchema, _models.Error]:
        """Create a New Kubernetes Cluster.

        To create a new Kubernetes cluster, send a POST request to
        ``/v2/kubernetes/clusters``. The request must contain at least one node pool
        with at least one worker.

        The request may contain a maintenance window policy describing a time period
        when disruptive maintenance tasks may be carried out. Omitting the policy
        implies that a window will be chosen automatically. See
        `here <https://www.digitalocean.com/docs/kubernetes/how-to/upgrade-cluster/>`_
        for details.

        :param body:
        :type body: ~digital_ocean_api.models.Cluster
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentsTzd5NlResponsesClusterCreateContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.ComponentsTzd5NlResponsesClusterCreateContentApplicationJsonSchema or
         ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.ComponentsTzd5NlResponsesClusterCreateContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'Cluster')

        request = build_kubernetes_cluster_request(
            content_type=content_type,
            json=_json,
            template_url=self.kubernetes_cluster.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('ComponentsTzd5NlResponsesClusterCreateContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    kubernetes_cluster.metadata = {'url': "/v2/kubernetes/clusters"}  # type: ignore


    @distributed_trace_async
    async def load_balancer(
        self,
        body: Any,
        **kwargs: Any
    ) -> Union[_models.Components19UpsdbResponsesLoadBalancerCreateContentApplicationJsonSchema, _models.Error]:
        """Create a New Load Balancer.

        To create a new load balancer instance, send a POST request to
        ``/v2/load_balancers``.

        You can specify the Droplets that will sit behind the load balancer using one
        of two methods:


        * Set ``droplet_ids`` to a list of specific Droplet IDs.
        * Set ``tag`` to the name of a tag. All Droplets with this tag applied will be
          assigned to the load balancer. Additional Droplets will be automatically
          assigned as they are tagged.

        These methods are mutually exclusive.

        :param body:
        :type body: any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components19UpsdbResponsesLoadBalancerCreateContentApplicationJsonSchema or Error, or
         the result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components19UpsdbResponsesLoadBalancerCreateContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components19UpsdbResponsesLoadBalancerCreateContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'object')

        request = build_load_balancer_request(
            content_type=content_type,
            json=_json,
            template_url=self.load_balancer.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 202:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components19UpsdbResponsesLoadBalancerCreateContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    load_balancer.metadata = {'url': "/v2/load_balancers"}  # type: ignore


    @distributed_trace_async
    async def alert_policy(
        self,
        body: _models.AlertPolicyRequest,
        **kwargs: Any
    ) -> Union[_models.AlertPolicy, _models.Error]:
        """Create Alert Policy.

        To create a new alert, send a POST request to ``/v2/monitoring/alerts``.

        :param body: The ``type`` field dictates what type of entity that the alert policy applies to
         and hence what type of entity is passed in the ``entities`` array. If both the ``tags`` array
         and ``entities`` array are empty the alert policy applies to all entities of the relevant type
         that are owned by the user account. Otherwise the following table shows the valid entity types
         for each type of alert policy:

         .. list-table::
            :header-rows: 1

            * - Type
              - Description
              - Valid Entity Type
            * - ``v1/insights/droplet/memory_utilization_percent``
              - alert on the percent of memory utilization
              - Droplet ID
            * - ``v1/insights/droplet/disk_read``
              - alert on the rate of disk read I/O in MBps
              - Droplet ID
            * - ``v1/insights/droplet/load_5``
              - alert on the 5 minute load average
              - Droplet ID
            * - ``v1/insights/droplet/load_15``
              - alert on the 15 minute load average
              - Droplet ID
            * - ``v1/insights/droplet/disk_utilization_percent``
              - alert on the percent of disk utilization
              - Droplet ID
            * - ``v1/insights/droplet/cpu``
              - alert on the percent of CPU utilization
              - Droplet ID
            * - ``v1/insights/droplet/disk_write``
              - alert on the rate of disk write I/O in MBps
              - Droplet ID
            * - ``v1/insights/droplet/public_outbound_bandwidth``
              - alert on the rate of public outbound bandwidth in Mbps
              - Droplet ID
            * - ``v1/insights/droplet/public_inbound_bandwidth``
              - alert on the rate of public inbound bandwidth in Mbps
              - Droplet ID
            * - ``v1/insights/droplet/private_outbound_bandwidth``
              - alert on the rate of private outbound bandwidth in Mbps
              - Droplet ID
            * - ``v1/insights/droplet/private_inbound_bandwidth``
              - alert on the rate of private inbound bandwidth in Mbps
              - Droplet ID
            * - ``v1/insights/droplet/load_1``
              - alert on the 1 minute load average
              - Droplet ID
            * - ``v1/insights/lbaas/avg_cpu_utilization_percent``
              - alert on the percent of CPU utilization
              - load balancer ID
            * - ``v1/insights/lbaas/connection_utilization_percent``
              - alert on the percent of connection utilization
              - load balancer ID
            * - ``v1/insights/lbaas/droplet_health``
              - alert on Droplet health status changes
              - load balancer ID.
        :type body: ~digital_ocean_api.models.AlertPolicyRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AlertPolicy or Error, or the result of cls(response)
        :rtype: ~digital_ocean_api.models.AlertPolicy or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.AlertPolicy, _models.Error]]

        _json = self._serialize.body(body, 'AlertPolicyRequest')

        request = build_alert_policy_request(
            content_type=content_type,
            json=_json,
            template_url=self.alert_policy.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('AlertPolicy', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    alert_policy.metadata = {'url': "/v2/monitoring/alerts"}  # type: ignore


    @distributed_trace_async
    async def project(
        self,
        body: _models.Paths1RzpbdoV2ProjectsPostRequestbodyContentApplicationJsonSchema,
        **kwargs: Any
    ) -> Union[_models.Components7Bz540ResponsesExistingProjectContentApplicationJsonSchema, _models.Error]:
        """Create a Project.

        To create a project, send a POST request to ``/v2/projects``.

        :param body:
        :type body:
         ~digital_ocean_api.models.Paths1RzpbdoV2ProjectsPostRequestbodyContentApplicationJsonSchema
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components7Bz540ResponsesExistingProjectContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components7Bz540ResponsesExistingProjectContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components7Bz540ResponsesExistingProjectContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'Paths1RzpbdoV2ProjectsPostRequestbodyContentApplicationJsonSchema')

        request = build_project_request(
            content_type=content_type,
            json=_json,
            template_url=self.project.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components7Bz540ResponsesExistingProjectContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    project.metadata = {'url': "/v2/projects"}  # type: ignore


    @distributed_trace_async
    async def registry(
        self,
        body: _models.RegistryCreate,
        **kwargs: Any
    ) -> Union[_models.Components19XzcfnResponsesRegistryInfoContentApplicationJsonSchema, _models.Error]:
        """Create Container Registry.

        To create your container registry, send a POST request to ``/v2/registry``.

        The ``name`` becomes part of the URL for images stored in the registry. For
        example, if your registry is called ``example``\ , an image in it will have the
        URL ``registry.digitalocean.com/example/image:tag``.

        :param body:
        :type body: ~digital_ocean_api.models.RegistryCreate
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components19XzcfnResponsesRegistryInfoContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components19XzcfnResponsesRegistryInfoContentApplicationJsonSchema or
         ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components19XzcfnResponsesRegistryInfoContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'RegistryCreate')

        request = build_registry_request(
            content_type=content_type,
            json=_json,
            template_url=self.registry.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components19XzcfnResponsesRegistryInfoContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    registry.metadata = {'url': "/v2/registry"}  # type: ignore


    @distributed_trace_async
    async def new_tag(
        self,
        body: _models.Tag,
        **kwargs: Any
    ) -> Union[_models.Components12Klsz5ResponsesNewTagContentApplicationJsonSchema, _models.ErrorWithRootCauses, _models.Error]:
        """Create a New Tag.

        To create a tag you can send a POST request to ``/v2/tags`` with a ``name`` attribute.

        :param body:
        :type body: ~digital_ocean_api.models.Tag
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components12Klsz5ResponsesNewTagContentApplicationJsonSchema or ErrorWithRootCauses or
         Error, or the result of cls(response)
        :rtype: ~digital_ocean_api.models.Components12Klsz5ResponsesNewTagContentApplicationJsonSchema
         or ~digital_ocean_api.models.ErrorWithRootCauses or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components12Klsz5ResponsesNewTagContentApplicationJsonSchema, _models.ErrorWithRootCauses, _models.Error]]

        _json = self._serialize.body(body, 'Tag')

        request = build_new_tag_request(
            content_type=content_type,
            json=_json,
            template_url=self.new_tag.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components12Klsz5ResponsesNewTagContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 400:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            response_headers['x-request-id']=self._deserialize('str', response.headers.get('x-request-id'))
            
            deserialized = self._deserialize('ErrorWithRootCauses', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    new_tag.metadata = {'url': "/v2/tags"}  # type: ignore


    @distributed_trace_async
    async def new_volume(
        self,
        body: Any,
        **kwargs: Any
    ) -> Union[_models.Components10939PsResponsesVolumeContentApplicationJsonSchema, _models.Error]:
        """Create a New Block Storage Volume.

        To create a new volume, send a POST request to ``/v2/volumes``. Optionally, a
        ``filesystem_type`` attribute may be provided in order to automatically format the volume's
        filesystem. Pre-formatted volumes are automatically mounted when attached to Ubuntu, Debian,
        Fedora, Fedora Atomic, and CentOS Droplets created on or after April 26, 2018. Attaching
        pre-formatted volumes to Droplets without support for auto-mounting is not recommended.

        :param body:
        :type body: any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components10939PsResponsesVolumeContentApplicationJsonSchema or Error, or the result
         of cls(response)
        :rtype: ~digital_ocean_api.models.Components10939PsResponsesVolumeContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components10939PsResponsesVolumeContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'object')

        request = build_new_volume_request(
            content_type=content_type,
            json=_json,
            template_url=self.new_volume.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 404, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components10939PsResponsesVolumeContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 400:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 404:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    new_volume.metadata = {'url': "/v2/volumes"}  # type: ignore


    @distributed_trace_async
    async def volume_snapshot(
        self,
        body: _models.Paths1Vjb9PvV2VolumesVolumeIdSnapshotsPostRequestbodyContentApplicationJsonSchema,
        **kwargs: Any
    ) -> Union[_models.Components12Eybj8ResponsesVolumeSnapshotContentApplicationJsonSchema, _models.Error]:
        """Create Snapshot from a Volume.

        To create a snapshot from a volume, sent a POST request to
        ``/v2/volumes/$VOLUME_ID/snapshots``.

        :param body:
        :type body:
         ~digital_ocean_api.models.Paths1Vjb9PvV2VolumesVolumeIdSnapshotsPostRequestbodyContentApplicationJsonSchema
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components12Eybj8ResponsesVolumeSnapshotContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components12Eybj8ResponsesVolumeSnapshotContentApplicationJsonSchema
         or ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components12Eybj8ResponsesVolumeSnapshotContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'Paths1Vjb9PvV2VolumesVolumeIdSnapshotsPostRequestbodyContentApplicationJsonSchema')

        request = build_volume_snapshot_request(
            volume_id=self._config.volume_id,
            content_type=content_type,
            json=_json,
            template_url=self.volume_snapshot.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 404, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components12Eybj8ResponsesVolumeSnapshotContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 400:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 404:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    volume_snapshot.metadata = {'url': "/v2/volumes/{volume_id}/snapshots"}  # type: ignore


    @distributed_trace_async
    async def vpc(
        self,
        body: _models.Paths1853Y6RV2VpcsPostRequestbodyContentApplicationJsonSchema,
        **kwargs: Any
    ) -> Union[_models.Components11RtrfgResponsesExistingVpcContentApplicationJsonSchema, _models.Error]:
        """Create a New VPC.

        To create a VPC, send a POST request to ``/v2/vpcs`` specifying the attributes
        in the table below in the JSON body.

        **Note:** If you do not currently have a VPC network in a specific datacenter
        region, the first one that you create will be set as the default for that
        region. The default VPC for a region cannot be changed or deleted.

        :param body:
        :type body:
         ~digital_ocean_api.models.Paths1853Y6RV2VpcsPostRequestbodyContentApplicationJsonSchema
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Components11RtrfgResponsesExistingVpcContentApplicationJsonSchema or Error, or the
         result of cls(response)
        :rtype:
         ~digital_ocean_api.models.Components11RtrfgResponsesExistingVpcContentApplicationJsonSchema or
         ~digital_ocean_api.models.Error
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Union[_models.Components11RtrfgResponsesExistingVpcContentApplicationJsonSchema, _models.Error]]

        _json = self._serialize.body(body, 'Paths1853Y6RV2VpcsPostRequestbodyContentApplicationJsonSchema')

        request = build_vpc_request(
            content_type=content_type,
            json=_json,
            template_url=self.vpc.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 429, 500]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Components11RtrfgResponsesExistingVpcContentApplicationJsonSchema', pipeline_response)

        if response.status_code == 401:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 429:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if response.status_code == 500:
            response_headers['ratelimit-limit']=self._deserialize('int', response.headers.get('ratelimit-limit'))
            response_headers['ratelimit-remaining']=self._deserialize('int', response.headers.get('ratelimit-remaining'))
            response_headers['ratelimit-reset']=self._deserialize('int', response.headers.get('ratelimit-reset'))
            
            deserialized = self._deserialize('Error', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    vpc.metadata = {'url': "/v2/vpcs"}  # type: ignore

